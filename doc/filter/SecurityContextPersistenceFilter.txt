SecurityContextPersistenceFilter已经废弃，可以看SecurityContextHolderFilter

SecurityContextPersistenceFilter在整个过滤器链中排在了第二的位置，由此可见该过滤器的重要性，并且从该过滤器的名字大概可以看出它主要作用是持久化SecurityContext（安全上下文信息），即将整个安全相关的信息保存起来，这样下游的其它过滤器就可以使用这个安全信息进行相关的操作了。


默认用DelegatingSecurityContextRepository

SecurityContextConfigurer.getSecurityContextRepository()

			securityContextRepository = new DelegatingSecurityContextRepository(
					new RequestAttributeSecurityContextRepository(), new HttpSessionSecurityContextRepository());


分析到这，SecurityContext从创建到获取再到销毁的整个流程大概都理清了，而且我们发现最终SecurityContext是通过另一个SecurityContextHolder类来存储和销毁的，这似乎和SecurityContextRepository有点重复的概念在里面，我的理解是SecurityContextRepository负责初始化生成并保存SecurityContext信息，当下次请求时就可以从session中获取上一次的SecurityContext信息了，相当于缓存的作用。而SecurityContextHolder则负责作为一个载体将查询出来的SecurityContext保存在其中，下游过滤器就可以从SecurityContextHolder中获取到SecurityContext内部的Authentication信息了。



SecurityContextPersistenceFilter在请求初始化时通过默认的HttpSessionSecurityContextRepository创建一个新的SecurityContext，首先是从当前session中获取SecurityContext，如果没有则通过SecurityContextHolder的createEmptyContext方法生成一个空的SecurityContext，然后将这个SecurityContext保存到SecurityContextHolder中
SecurityContextHolder本身不保存SecurityContext，它是通过内部维护的一个SecurityContextHolderStrategy来保存SecurityContext的，Spring Security自带了ThreadLocalSecurityContextHolderStrategy（默认的保存策略），InheritableThreadLocalSecurityContextHolderStrategy和GlobalSecurityContextHolderStrategy这三种策略，当然也可以自定义策略
SecurityContextHolder将SecurityContext保存到内部的SecurityContextHolderStrategy中后，下游的其它过滤器就可以取这个SecurityContext了进行认证或者授权了

https://www.zyc.red/Spring/Security/Spring-Security%E6%A0%B8%E5%BF%83%E8%BF%87%E6%BB%A4%E5%99%A8/SecurityContextPersistenceFilter/
